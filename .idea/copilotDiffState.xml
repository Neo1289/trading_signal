<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bitcoin_predictor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bitcoin_predictor.py" />
              <option name="originalContent" value="import pandas as pd&#10;import numpy as np&#10;from sklearn.ensemble import RandomForestClassifier&#10;from sklearn.model_selection import train_test_split&#10;from sklearn.preprocessing import StandardScaler&#10;from sklearn.metrics import accuracy_score, classification_report&#10;from google.cloud import bigquery&#10;from google.oauth2 import service_account&#10;import logging&#10;import warnings&#10;warnings.filterwarnings('ignore')&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class BitcoinPredictor:&#10;    def __init__(self, credentials_path: str):&#10;        self.credentials = service_account.Credentials.from_service_account_file(credentials_path)&#10;        self.client = bigquery.Client(credentials=self.credentials, project=&quot;connection-123&quot;)&#10;        self.model = RandomForestClassifier(n_estimators=100, random_state=42)&#10;        self.scaler = StandardScaler()&#10;&#10;    def fetch_all_indicators(self) -&gt; pd.DataFrame:&#10;        &quot;&quot;&quot;Fetch and combine all technical indicators from BigQuery&quot;&quot;&quot;&#10;&#10;        # Main query joining all indicator tables&#10;        query = &quot;&quot;&quot;&#10;        WITH base_data AS (&#10;            SELECT &#10;                p.timestamp as date_,&#10;                p.price,&#10;                p.market_cap,&#10;                p.total_volume,&#10;                ma.sma_10,&#10;                ma.sma_20,&#10;                ma.sma_50,&#10;                ema.ema_9,&#10;                ema.ema_12,&#10;                ema.ema_26,&#10;                ema.ema_20,&#10;                ema.ema_50,&#10;                ema.ema_200,&#10;                rsi.rsi_14,&#10;                macd.macd_line,&#10;                macd.signal_line,&#10;                macd.histogram,&#10;                bb.middle_band,&#10;                bb.upper_band,&#10;                bb.lower_band,&#10;                bb.bb_width,&#10;                bb.percent_b&#10;            FROM `connection-123.signals.bitcoin_price` p&#10;            LEFT JOIN `connection-123.signals.btc_moving_averages` ma ON p.timestamp = ma.date_&#10;            LEFT JOIN `connection-123.signals.btc_ema` ema ON p.timestamp = ema.timestamp&#10;            LEFT JOIN `connection-123.signals.btc_rsi` rsi ON p.timestamp = rsi.timestamp&#10;            LEFT JOIN `connection-123.signals.btc_macd` macd ON p.timestamp = macd.timestamp&#10;            LEFT JOIN `connection-123.signals.btc_bollinger_bands` bb ON p.timestamp = bb.timestamp&#10;            WHERE p.timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 60 DAY) AND DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)&#10;            ORDER BY p.timestamp&#10;        )&#10;        SELECT *&#10;        FROM base_data&#10;        WHERE sma_10 IS NOT NULL  -- Ensure we have indicator data&#10;        &quot;&quot;&quot;&#10;&#10;        query_job = self.client.query(query)&#10;        df = query_job.result().to_dataframe()&#10;&#10;        logger.info(f&quot;Fetched {len(df)} rows of combined indicator data&quot;)&#10;        return df&#10;&#10;    def create_features(self, df: pd.DataFrame) -&gt; pd.DataFrame:&#10;        &quot;&quot;&quot;Create additional features and target variable&quot;&quot;&quot;&#10;&#10;        # Sort by date to ensure proper order&#10;        df = df.sort_values('date_').reset_index(drop=True)&#10;&#10;        # Price momentum features&#10;        df['price_change_1d'] = df['price'].pct_change(1)&#10;        df['price_change_3d'] = df['price'].pct_change(3)&#10;        df['price_change_7d'] = df['price'].pct_change(7)&#10;&#10;        # Volume features&#10;        df['volume_ma_7'] = df['total_volume'].rolling(7).mean()&#10;        df['volume_ratio'] = df['total_volume'] / df['volume_ma_7']&#10;&#10;        # Moving average ratios&#10;        df['price_sma10_ratio'] = df['price'] / df['sma_10']&#10;        df['price_sma20_ratio'] = df['price'] / df['sma_20']&#10;        df['price_sma50_ratio'] = df['price'] / df['sma_50']&#10;        df['sma10_sma20_ratio'] = df['sma_10'] / df['sma_20']&#10;&#10;        # EMA features&#10;        df['ema12_ema26_diff'] = df['ema_12'] - df['ema_26']&#10;        df['price_ema20_ratio'] = df['price'] / df['ema_20']&#10;&#10;        # Bollinger Bands position&#10;        df['bb_position'] = (df['price'] - df['lower_band']) / (df['upper_band'] - df['lower_band'])&#10;&#10;        # MACD momentum&#10;        df['macd_momentum'] = df['macd_line'] - df['signal_line']&#10;&#10;        # Target: 1 if price goes up in next 3 days, 0 if down&#10;        df['future_price'] = df['price'].shift(-3)&#10;        df['target'] = (df['future_price'] &gt; df['price']).astype(int)&#10;&#10;        # Remove rows with NaN values&#10;        df = df.dropna().reset_index(drop=True)&#10;&#10;        return df&#10;&#10;    def prepare_features(self, df: pd.DataFrame) -&gt; tuple:&#10;        &quot;&quot;&quot;Select and prepare features for training&quot;&quot;&quot;&#10;&#10;        feature_columns = [&#10;            'price_change_1d', 'price_change_3d', 'price_change_7d',&#10;            'volume_ratio', 'price_sma10_ratio', 'price_sma20_ratio',&#10;            'price_sma50_ratio', 'sma10_sma20_ratio', 'ema12_ema26_diff',&#10;            'price_ema20_ratio', 'bb_position', 'bandwidth', 'percent_b',&#10;            'rsi_14', 'macd_momentum', 'histogram'&#10;        ]&#10;&#10;        X = df[feature_columns].copy()&#10;        y = df['target'].copy()&#10;&#10;        # Handle any remaining NaN values&#10;        X = X.fillna(X.mean())&#10;&#10;        return X, y, feature_columns&#10;&#10;    def train_model(self) -&gt; dict:&#10;        &quot;&quot;&quot;Train the prediction model&quot;&quot;&quot;&#10;&#10;        # Fetch and prepare data&#10;        df = self.fetch_all_indicators()&#10;        df = self.create_features(df)&#10;        X, y, feature_columns = self.prepare_features(df)&#10;&#10;        # Split data&#10;        X_train, X_test, y_train, y_test = train_test_split(&#10;            X, y, test_size=0.2, random_state=42, stratify=y&#10;        )&#10;&#10;        # Scale features&#10;        X_train_scaled = self.scaler.fit_transform(X_train)&#10;        X_test_scaled = self.scaler.transform(X_test)&#10;&#10;        # Train model&#10;        self.model.fit(X_train_scaled, y_train)&#10;&#10;        # Evaluate&#10;        y_pred = self.model.predict(X_test_scaled)&#10;        accuracy = accuracy_score(y_test, y_pred)&#10;&#10;        # Feature importance&#10;        feature_importance = pd.DataFrame({&#10;            'feature': feature_columns,&#10;            'importance': self.model.feature_importances_&#10;        }).sort_values('importance', ascending=False)&#10;&#10;        results = {&#10;            'accuracy': accuracy,&#10;            'feature_importance': feature_importance,&#10;            'classification_report': classification_report(y_test, y_pred)&#10;        }&#10;&#10;        logger.info(f&quot;Model trained with accuracy: {accuracy:.4f}&quot;)&#10;        return results&#10;&#10;    def predict_direction(self) -&gt; dict:&#10;        &quot;&quot;&quot;Predict Bitcoin direction for next 3 days&quot;&quot;&quot;&#10;&#10;        # Get latest data&#10;        df = self.fetch_all_indicators()&#10;        df = self.create_features(df)&#10;&#10;        # Get the most recent complete row&#10;        latest_data = df.iloc[-1:].copy()&#10;        X_latest, _, feature_columns = self.prepare_features(latest_data)&#10;&#10;        # Scale and predict&#10;        X_latest_scaled = self.scaler.transform(X_latest)&#10;        prediction = self.model.predict(X_latest_scaled)[0]&#10;        probability = self.model.predict_proba(X_latest_scaled)[0]&#10;&#10;        direction = &quot;UP&quot; if prediction == 1 else &quot;DOWN&quot;&#10;        confidence = max(probability)&#10;&#10;        return {&#10;            'direction': direction,&#10;            'confidence': confidence,&#10;            'probability_up': probability[1],&#10;            'probability_down': probability[0],&#10;            'current_price': latest_data['price'].iloc[0],&#10;            'date': latest_data['date_'].iloc[0]&#10;        }&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to run Bitcoin prediction&quot;&quot;&quot;&#10;&#10;    # Initialize predictor&#10;    credentials_path = &quot;connection-123-892e002c2def.json&quot;&#10;    predictor = BitcoinPredictor(credentials_path)&#10;&#10;    # Train model&#10;    print(&quot;Training Bitcoin direction prediction model...&quot;)&#10;    results = predictor.train_model()&#10;&#10;    print(f&quot;\nModel Performance:&quot;)&#10;    print(f&quot;Accuracy: {results['accuracy']:.4f}&quot;)&#10;    print(f&quot;\nTop 5 Important Features:&quot;)&#10;    print(results['feature_importance'].head())&#10;&#10;    # Make prediction&#10;    print(&quot;\nPredicting Bitcoin direction for next 3 days...&quot;)&#10;    prediction = predictor.predict_direction()&#10;&#10;    print(f&quot;\nPrediction Results:&quot;)&#10;    print(f&quot;Current Price: ${prediction['current_price']:,.2f}&quot;)&#10;    print(f&quot;Prediction Date: {prediction['date']}&quot;)&#10;    print(f&quot;Direction (3 days): {prediction['direction']}&quot;)&#10;    print(f&quot;Confidence: {prediction['confidence']:.4f}&quot;)&#10;    print(f&quot;Probability UP: {prediction['probability_up']:.4f}&quot;)&#10;    print(f&quot;Probability DOWN: {prediction['probability_down']:.4f}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import pandas as pd&#10;import numpy as np&#10;from sklearn.ensemble import RandomForestClassifier&#10;from sklearn.model_selection import train_test_split&#10;from sklearn.preprocessing import StandardScaler&#10;from sklearn.metrics import accuracy_score, classification_report&#10;from google.cloud import bigquery&#10;from google.oauth2 import service_account&#10;import logging&#10;import warnings&#10;warnings.filterwarnings('ignore')&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;class BitcoinPredictor:&#10;    def __init__(self, credentials_path: str):&#10;        self.credentials = service_account.Credentials.from_service_account_file(credentials_path)&#10;        self.client = bigquery.Client(credentials=self.credentials, project=&quot;connection-123&quot;)&#10;        self.model = RandomForestClassifier(n_estimators=100, random_state=42)&#10;        self.scaler = StandardScaler()&#10;&#10;    def fetch_all_indicators(self) -&gt; pd.DataFrame:&#10;        &quot;&quot;&quot;Fetch and combine all technical indicators from BigQuery&quot;&quot;&quot;&#10;&#10;        # Main query joining all indicator tables&#10;        query = &quot;&quot;&quot;&#10;        WITH base_data AS (&#10;            SELECT &#10;                p.timestamp as date_,&#10;                p.price,&#10;                p.market_cap,&#10;                p.total_volume,&#10;                ma.sma_10,&#10;                ma.sma_20,&#10;                ma.sma_50,&#10;                ema.ema_9,&#10;                ema.ema_12,&#10;                ema.ema_26,&#10;                ema.ema_20,&#10;                ema.ema_50,&#10;                ema.ema_200,&#10;                rsi.rsi_14,&#10;                macd.macd_line,&#10;                macd.signal_line,&#10;                macd.histogram,&#10;                bb.middle_band,&#10;                bb.upper_band,&#10;                bb.lower_band,&#10;                bb.bb_width,&#10;                bb.percent_b&#10;            FROM `connection-123.signals.bitcoin_price` p&#10;            LEFT JOIN `connection-123.signals.btc_moving_averages` ma ON p.timestamp = ma.date_&#10;            LEFT JOIN `connection-123.signals.btc_ema` ema ON p.timestamp = ema.timestamp&#10;            LEFT JOIN `connection-123.signals.btc_rsi` rsi ON p.timestamp = rsi.timestamp&#10;            LEFT JOIN `connection-123.signals.btc_macd` macd ON p.timestamp = macd.timestamp&#10;            LEFT JOIN `connection-123.signals.btc_bollinger_bands` bb ON p.timestamp = bb.timestamp&#10;            WHERE p.timestamp BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 60 DAY) AND DATE_SUB(CURRENT_DATE(), INTERVAL 1 DAY)&#10;            ORDER BY p.timestamp&#10;        )&#10;        SELECT *&#10;        FROM base_data&#10;        WHERE sma_10 IS NOT NULL  -- Ensure we have indicator data&#10;        &quot;&quot;&quot;&#10;&#10;        query_job = self.client.query(query)&#10;        df = query_job.result().to_dataframe()&#10;&#10;        logger.info(f&quot;Fetched {len(df)} rows of combined indicator data&quot;)&#10;        return df&#10;&#10;    def create_features(self, df: pd.DataFrame) -&gt; pd.DataFrame:&#10;        &quot;&quot;&quot;Create additional features and target variable&quot;&quot;&quot;&#10;&#10;        # Sort by date to ensure proper order&#10;        df = df.sort_values('date_').reset_index(drop=True)&#10;&#10;        # Price momentum features&#10;        df['price_change_1d'] = df['price'].pct_change(1)&#10;        df['price_change_3d'] = df['price'].pct_change(3)&#10;        df['price_change_7d'] = df['price'].pct_change(7)&#10;&#10;        # Volume features&#10;        df['volume_ma_7'] = df['total_volume'].rolling(7).mean()&#10;        df['volume_ratio'] = df['total_volume'] / df['volume_ma_7']&#10;&#10;        # Moving average ratios&#10;        df['price_sma10_ratio'] = df['price'] / df['sma_10']&#10;        df['price_sma20_ratio'] = df['price'] / df['sma_20']&#10;        df['price_sma50_ratio'] = df['price'] / df['sma_50']&#10;        df['sma10_sma20_ratio'] = df['sma_10'] / df['sma_20']&#10;&#10;        # EMA features&#10;        df['ema12_ema26_diff'] = df['ema_12'] - df['ema_26']&#10;        df['price_ema20_ratio'] = df['price'] / df['ema_20']&#10;&#10;        # Bollinger Bands position&#10;        df['bb_position'] = (df['price'] - df['lower_band']) / (df['upper_band'] - df['lower_band'])&#10;&#10;        # MACD momentum&#10;        df['macd_momentum'] = df['macd_line'] - df['signal_line']&#10;&#10;        # Target: 1 if price goes up in next 3 days, 0 if down&#10;        df['future_price'] = df['price'].shift(-3)&#10;        df['target'] = (df['future_price'] &gt; df['price']).astype(int)&#10;&#10;        # Remove rows with NaN values&#10;        df = df.dropna().reset_index(drop=True)&#10;&#10;        return df&#10;&#10;    def prepare_features(self, df: pd.DataFrame) -&gt; tuple:&#10;        &quot;&quot;&quot;Select and prepare features for training&quot;&quot;&quot;&#10;&#10;        feature_columns = [&#10;            'price_change_1d', 'price_change_3d', 'price_change_7d',&#10;            'volume_ratio', 'price_sma10_ratio', 'price_sma20_ratio',&#10;            'price_sma50_ratio', 'sma10_sma20_ratio', 'ema12_ema26_diff',&#10;            'price_ema20_ratio', 'bb_position', 'bb_width', 'percent_b',&#10;            'rsi_14', 'macd_momentum', 'histogram'&#10;        ]&#10;&#10;        X = df[feature_columns].copy()&#10;        y = df['target'].copy()&#10;&#10;        # Handle any remaining NaN values&#10;        X = X.fillna(X.mean())&#10;&#10;        return X, y, feature_columns&#10;&#10;    def train_model(self) -&gt; dict:&#10;        &quot;&quot;&quot;Train the prediction model&quot;&quot;&quot;&#10;&#10;        # Fetch and prepare data&#10;        df = self.fetch_all_indicators()&#10;        df = self.create_features(df)&#10;        X, y, feature_columns = self.prepare_features(df)&#10;&#10;        # Split data&#10;        X_train, X_test, y_train, y_test = train_test_split(&#10;            X, y, test_size=0.2, random_state=42, stratify=y&#10;        )&#10;&#10;        # Scale features&#10;        X_train_scaled = self.scaler.fit_transform(X_train)&#10;        X_test_scaled = self.scaler.transform(X_test)&#10;&#10;        # Train model&#10;        self.model.fit(X_train_scaled, y_train)&#10;&#10;        # Evaluate&#10;        y_pred = self.model.predict(X_test_scaled)&#10;        accuracy = accuracy_score(y_test, y_pred)&#10;&#10;        # Feature importance&#10;        feature_importance = pd.DataFrame({&#10;            'feature': feature_columns,&#10;            'importance': self.model.feature_importances_&#10;        }).sort_values('importance', ascending=False)&#10;&#10;        results = {&#10;            'accuracy': accuracy,&#10;            'feature_importance': feature_importance,&#10;            'classification_report': classification_report(y_test, y_pred)&#10;        }&#10;&#10;        logger.info(f&quot;Model trained with accuracy: {accuracy:.4f}&quot;)&#10;        return results&#10;&#10;    def predict_direction(self) -&gt; dict:&#10;        &quot;&quot;&quot;Predict Bitcoin direction for next 3 days&quot;&quot;&quot;&#10;&#10;        # Get latest data&#10;        df = self.fetch_all_indicators()&#10;        df = self.create_features(df)&#10;&#10;        # Get the most recent complete row&#10;        latest_data = df.iloc[-1:].copy()&#10;        X_latest, _, feature_columns = self.prepare_features(latest_data)&#10;&#10;        # Scale and predict&#10;        X_latest_scaled = self.scaler.transform(X_latest)&#10;        prediction = self.model.predict(X_latest_scaled)[0]&#10;        probability = self.model.predict_proba(X_latest_scaled)[0]&#10;&#10;        direction = &quot;UP&quot; if prediction == 1 else &quot;DOWN&quot;&#10;        confidence = max(probability)&#10;&#10;        return {&#10;            'direction': direction,&#10;            'confidence': confidence,&#10;            'probability_up': probability[1],&#10;            'probability_down': probability[0],&#10;            'current_price': latest_data['price'].iloc[0],&#10;            'date': latest_data['date_'].iloc[0]&#10;        }&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to run Bitcoin prediction&quot;&quot;&quot;&#10;&#10;    # Initialize predictor&#10;    credentials_path = &quot;connection-123-892e002c2def.json&quot;&#10;    predictor = BitcoinPredictor(credentials_path)&#10;&#10;    # Train model&#10;    print(&quot;Training Bitcoin direction prediction model...&quot;)&#10;    results = predictor.train_model()&#10;&#10;    print(f&quot;\nModel Performance:&quot;)&#10;    print(f&quot;Accuracy: {results['accuracy']:.4f}&quot;)&#10;    print(f&quot;\nTop 5 Important Features:&quot;)&#10;    print(results['feature_importance'].head())&#10;&#10;    # Make prediction&#10;    print(&quot;\nPredicting Bitcoin direction for next 3 days...&quot;)&#10;    prediction = predictor.predict_direction()&#10;&#10;    print(f&quot;\nPrediction Results:&quot;)&#10;    print(f&quot;Current Price: ${prediction['current_price']:,.2f}&quot;)&#10;    print(f&quot;Prediction Date: {prediction['date']}&quot;)&#10;    print(f&quot;Direction (3 days): {prediction['direction']}&quot;)&#10;    print(f&quot;Confidence: {prediction['confidence']:.4f}&quot;)&#10;    print(f&quot;Probability UP: {prediction['probability_up']:.4f}&quot;)&#10;    print(f&quot;Probability DOWN: {prediction['probability_down']:.4f}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>